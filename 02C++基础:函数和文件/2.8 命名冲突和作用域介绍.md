# 命名冲突和命名空间介绍

比如说，你第一次开车去朋友家，给你的地址是245 Front Street in Mill City。到达Mill City后，你打开地图，却发现Mill City其实有两个不同的Front Street, 你会去哪一条？除非有一条额外的线索帮你决定，否则你得打电话给你的朋友，询问更多的信息。因为这将是混乱和低效的(特别是对你的邮递员来说)，在大多数国家，一个城市的所有街道名称和房屋地址都必须是唯一的。

同样的，C++也要求所有的标识符都是没有歧义的。如果在同一个程序中引入两个相同的标识符，以至于编译器或者链接器无法区分它们，编译器或者链接器就会产生一个错误。这种错误一般被称为`命名冲突`

# 命名冲突的例子

a.cpp

```c++
#include <iostream>

void myFcn(int x)
{
  std::cout << x;
}
```

main.cpp

```c++
#include <iostream>

void myFcn(int x)
{
  std::cout << 2 * x;
}

int main()
{
  return 0;
}
```

编译器在编译这个程序的时候，会独立编译a.cp和main.cpp，每个文件的编译都没有问题。

然而，当链接器执行的时候，它会将a.cpp和main.cpp中所有定义链接在一起，并发现函数myFcn的定义有冲突。然后，链接器将中止。请注意，即使myFcn从未被调用过，这个错误也会发生。

大多数命名冲突发生在两个地方:

1. 一个函数(或者全局变量)的两个(或者多个)定义被引入到不同的文件中，并被编译到同一个程序。这将导致链接器错误，如上图所示。
2. 一个函数(或者全局变量)的两个(或者多个)定义被引入到同一个文件中(通常通过`#include`)。这将导致一个编译器错误

随着程序越来越大，使用的标识符越来越多，引入命名碰撞的几率就会大大增加。想消息是，C++提供了很多避免命名冲突的机制。局部作用域就是这样一种机制，它可以防止函数内部定义的局部变量相互冲突。但是局部作用域对函数名不起作用。那么我们如何防止函数名相互冲突呢？

# 什么是命名空间

回到我们的地址类比，有两条Front Street是有问题的。因为这两条街道存在于同一个城市。另一个方面，如果你必须将邮件送到两个地址，一个地址在209 Front Street in Mill City, 另外一个地址在417 Front Street in Jonesville, 那么就不会出现去向不明的情况。换句话来说，城市名提供了分组，让我们能够消除可能相互冲突的地址歧义。命名空间的作用就像这个类比中的城市一样。

命名空间是一个区域，允许你为了消除歧义而在其中声明名称。命名空间为其内部的声明提供了一个作用域(称为`命名空间作用域`) -- 简单来说，就是在命名空间内声明的任何名称不会被误认为是其他作用域内的相同名称。

> ### 主要见解
>
> 在一个命名空间中声明的名称不会被误认为是在另一个作用域中声明的相同名称

在一个命名空间内，所有的名字都必须是唯一的，否则将导致命名空间冲突。

命名空间通常用于将大型项目中的相关标识分组，以确保它们不会无意中与其他标识符发生冲突。比如，如果你把所有的数学函数都放在一个名为math的命名空间中，那么你的数学函数就不会与math命名空间之外的相同名称的函数发生冲突。

我们将在以后的课程中讨论如何创建自己的命名空间。

# 全局命名空间

在C++中，任何未在类、函数或者命名空间中定义的名称都被视为全局命名空间(有时也称为全局作用域)的一部分。

在本节顶部的示例中。函数main()和myFcn()的两个版本都定义在全局命名空间中。本例中遇到的命名冲突时因为myFunc()的两个版本最终都在全局命名空间中，这违反了命名空间中所有名字必须唯一的规则。

# std命名空间

在C++最初设计的时候，C++标准库中的所有标识符(包括std::cin，std::cout) 都可以在没有std:: 前缀的情况下使用(它们时全局命名空间的一部分)。然而，这意味着标准库中的任何标识符都可能与你写的标识符发生冲突。当你从标准库 #include 一个新的文件时，正在工作的代码可能突然出现命名冲突。或者更糟糕的是，在一个版本的C++下可以编译的程序可能在未来的C++版本下无法编译，因为引入标准库的新标识符可能会与已经写好的代码发生命名冲突。所以C++把标准库中的所有功能都移到了一个名为"std"(standard的简称)的命名空间中。

原来，`std::cout` 的名字并不是真正的`std::cout`。它实际上只是`cout`。而std是标识符cout所属的命名空间的名称。因为cout是在std命名空间中定义的，所以cout这个名字不会与我们在全局命名空间中创建的任何名为cout的对象或者函数冲突。

同样，当访问一个定义在命名空间中的标识符的时候(比如std::cout)，你需要告诉编译器，我们正在寻找一个定义在命名空间std内的标识符

> ### 主要见解
>
> 当你使用一个在命名空间(比如std命名空间)内定义的标识符时，你必须告诉编译器这个标识符就在命名空间内

有几种不同的方法可以做到这一点

# 显式命名空间限定符 std:: 

告诉编译器我们要使用来自std命名空间的cout的最直接方法就是明确使用std:: 前缀。比如，我们可以使用:

```c++
#include <iostream>

int main()
{
  std::cout << "Hello World!";  // 当我们谈cout的时候，我们指的是std命名空间中定义的cout
  return 0;
}
```

`::`符号是一个称为`作用域解析运算符`的运算符，`::`左边的标识符标识了`::`符号右边的名称包含在它的命名空间中。如果左侧没有提供，则假定为全局命名空间。

所以当我们说`std::cout`的时候，我们说的是`在命名空间std的cout`

> ### 最佳实践
>
> 使用显式命名空间前缀来访问在命名空间中定义的标识符

# using namespace std(为什么需要避免它)

另一种在命名空间内访问标识符的方法是使用using指令语句，下面是我们原来的"Hello World"程序，现在使用了using指令

```c++
#include <iostream>

using namespace std;  // 这是一个using指令，告诉编译器在解析没有前缀的标识符的时候检查std命名空间

int main()
{
  cout << "Hello world!";  // cout没有前缀，因此编译器会检查cout是在本地定义的还是在命名空间std中定义的
  return 0;
}
```

`using指令`告诉编译器在试图解析一个没有命名空间前缀的标识符的时候，要检查指定的命名空间。因此，在上面的例子中，当编译器去确定标识符cout是什么时，它将同时检查本地(在这里它没有被定义)和std命名空间(在这里它将匹配std::cout)

许多文章、教程，甚至一些编译器都推荐在代码顶部使用using指令。然而，以这种方式使用，是一种不好的做法，而且非常不鼓励。

考虑以下程序。

```c++
#include <iostream>  //  导入std::cout的声明

using namespace std;  //  使std::cout可以用cout访问

int cout() // 声明我们自己的cout函数
{
  return 5;
}

int main()
{
  cout << "Hello, world!"; // 编译错误，我们这里需要哪个cout？ 是std命名空间中的还是我们上面定义的?
  return 0;
}
```

上面的程序无法编译，因为编译器发现无法判断我们是要我们定义的cout函数，还是std命名空间里面定义的cout.

当以这种方式使用using 指令的时候，我们定义的任何标识符都可能和std命名空间中任何相同名称的标识符发生冲突。更糟糕的是，虽然一个标识符的名字今天可能不会冲突，但是它可能会和未来语言修订中添加到std命名空间的新标识符发生冲突。这就是当初把标准库中所有标识符移动到std命名空间的全部意义所在！

> ### 警告
>
> 避免在程序的顶部使用using 指令(比如using namespace std;) 它们违反了当初添加命名空间的初衷。

我们将在第 6.12 -- using语句 中进一步讨论using语句(以及如何负责任的使用它们)
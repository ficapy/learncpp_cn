# 局部作用域介绍



# 局部变量

函数参数，以及在函数体内定义的变量，被称为`局部变量`（和全局变量相反，我们将在以后的章节讨论）

```c++
int add(int x, int y) // 函数的形参x和y是局部变量
{
  int z{x +y};  // z也是局部变量
  return z;
}
```

在本节中，我们将更详细地了解局部变量的一些属性。

# 局部变量生命周期

在1.3节 -- 变量介绍 中，我们讨论了变量定义，比如`int x;`是如何在执行该语句时使变量被实例化(创建)的。函数形参是在输入函数时创建和初始化的，函数体中的变量时在定义时创建和初始化的。

比如:

```c++
int add(int x, int y)  // x和y创建并初始化
{
  int z{ x+ y };  // z在这里创建并初始化
  return z;
}
```

很自然的，后续问题是"那么一个实例化的变量会在什么时候被销毁呢"。局部变量的销毁顺序和创建顺序是相反的，是在定义它的大括号集合的末尾(或者对于函数来说，是在函数的末尾)。

```c++
int add(int x,int y)
{
  int z{x + y};
  return z;
}  // z,y和x在这里被销毁
```

就像一个人的一生被定义为出生和死亡之间一样。一个对象的一生被定义为创建和销毁之间的时间。请注意，变量的创建和销毁发生在程序的运行期间(称为运行时)，而不是在编译时。因此，生命周期时一个运行时属性。

> ### 给高级读者
>
> 以上关于创建、初始化和销毁的规则是有保证的。也就是说，创建和初始化对象的时间不得晚于定义，销毁对象的时间不得早于定义它们的大括号集合的结束时间(或者，对于函数参数，在函数结束的时候)。
>
> 实际上，C++规范给编译器提供了很大的灵活性来决定何时创建和销毁局部变量，对象可以提前创建，也可以出于优化目的晚一点销毁。大多数情况下，局部变量是在函数进入时创建的，而在函数退出时以相反的顺序销毁。我们将在以后的课程中，在讲到栈时详细讨论这个问题。

下面是一个有些复杂的程序，演示了一个名为x的变量的寿命

```c++
#include <iostream>

void doSomething()
{
  std::cout << "Hello!\n";
}

int main()
{
  int x{0};  // x的生命周期从这里开始
  doSomething(); // 在此函数调用期间，x仍然活着
  return 0；
} // x的生命周期在这里结束了
```

在上面的程序中，x的生命周期从定义点到函数main结束。这包括在执行doSomething期间花费的时间。

# 局部作用域

一个标识符的作用域决定了可以在源代码中访问标识符的位置。当一个标识符可以被访问的时候，我们说它在作用域内。当一个标识符不能被访问的时候，我们说它在作用域之外。作用域是一个编译时属性，当一个标识符不在范围时，试图使用它将导致编译器报错。

局部变量的作用域是从定义点开始，到定义它们的大括号集合结束(或者对于函数参数来说，是到函数结束)为止。这确保了变量不能在定义点之前被使用(即使编译器选择在那之前创建变量)。

这是一个演示变量x作用域的例子:

```c++
#include <iostream>

// x不在这个函数的作用域范围内
void doSomething()
{
  std::cout << "Hello!\n";
}

int main()
{
  // x 不能在这里使用，因为不在它的作用域内
  int x{0};  // 在这里x进入作用域，能够开始使用了
  doSomething();
  return 0;
} // 在这里x退出作用域并无法被使用
```

在上面的程序中，变量x在定义的时候进入作用域，在main函数结束的时候退出作用域。请注意，变量x不在函数doSomething的作用域内。在这个上下文中，函数main调用函数doSomething是不相关的。

请注意，局部变量的作用域和寿命的定义是一样的。对于局部变量来说，作用域和寿命是联系在一起的 -- 也就是说，一个变量的寿命从它进入作用域开始，到它离开作用域的时候结束。

# 另外一个例子

下面是稍微复杂一点的例子，请记住，生命周期是一个运行时属性，而scope是一个编译时属性，所以尽管我们在同一个程序中谈论着两个属性，但它们是在不同的点执行的

```c++
#include <iostream>

int add(int x, int y) // x和y在这里创建并进入作用域
{
  // x和y在这里可见 / 仅仅在这个函数内可以被使用
  return x + y;
} // y和x出作用域，然后在这里被销毁

int main()
{
  int a{5};  // a被创建、初始化并且进入作用域
  int b{6};  // b被创建、初始化并且进入作用域
  
  // a和b仅仅在这个函数内可以被使用
  std::cout << add(a, b) << '\n'; // 使用x =5,y=6调用add函数
  
  return 0;
} // a和b出了作用域，然后在这里被销毁
```

形参x和y是在调用add函数时创建的，只能在函数add中看到/使用，并且在add结束时被销毁。

为了加强你对所有这些是如何结合在一起的，让我们更详细的追踪这个程序，以下是按照发生的顺序

- 从main头部开始执行
- main创建了变量a并赋值为5
- main创建了变量b并赋值为6
- 调用函数add, 参数值为5和6
- add的变量x被创建并初始化为5
- add的变量y被创建并初始化为6
- operator+计算表达式x+y的值11
- 将值11拷贝回调用者main
- add函数的y和x被销毁
- main函数输出11到控制台
- main返回0给操作系统
- main函数的b和a被销毁

然后整个过程就结束了

请注意，如果函数add被调用两次，形参x和y将被创建和销毁两次。在一个有大量函数和函数调用的程序中，变量会经常被调用和销毁。

# 函数分离

在上面的例子中，很容易看出，变量a、b和变量x、y是不同的变量。

现在考虑以下程序

```c++
#include <iostream>

int add(int x, int y)   // add的x和y被创建，并在这里进入作用域
{
  // add的x和y只在这个函数内可见/可用
  return x + y;
} // add的y和x离开作用域，在这里被销毁

int main()
{
  int x{5};  // main里面，x被创建、初始化、进入作用域
  int y{6};  // main里面，y被创建、初始化、进入作用域
  // x和y只在这个函数内可见/可用
  std::cout << add(x, y) << '\n';
  return 0;
} // main的y和x离开作用域，在这里被销毁
```

在这个例子中，我们所做的只是将main函数中的变量a和变量b的名字改成x和y。这个程序的编译和运行都是一样的，尽管函数main和函数add都有名为x和y的变量。为什么会这样?

首先，我们需要意识到，尽管函数main和函数add都有名为x和y的变量，但是这些变量并不相同。函数main中的x和y于函数add中的x和y没有任何关系 -- 它们只是碰巧共享相同的名字。

其次，在函数main内部，x和y指向的是main的局部变量x和y，这些变量只能在main内部看到(和使用)。同样的，在函数add内部，x和y指向的是函数参数x和y，这些参数只能在add内部看到(和使用)。

简而言之，add和main都不知道另一个函数有相同的名字的变量。由于作用域不重叠，编译器在任何时候都能清楚地知道引用的是哪个x和y。

> ### 主要见解
>
> 用于函数参数或者在函数体中声明的变量的名称只有在声明它们的函数中可见，这意味着在一个函数中的局部变量的命名可以不用考虑其他函数中的变量名称。这有助于保持函数的独立性。

我们将在未来的章节中更详细的讨论局部变量，以及其他类型的作用域。

# 在哪里定义局部变量

函数体内部的局部变量的定义应该尽可能接近于它们的首次使用：

```c++
#include <iostream>

int main()
{
  std::cout << "Enter an integer: ";
  int x{};    // x在这里定义
  std::cin >> x;  // 在这里使用
  
  std::cout << "Enter another integer: ";
  int y{};    // y在这里定义
  std::cin >> y; // y在这里使用
  
  int sum{ x + y };  // sum在这里定义
  std::cout << "The sum is: " << sum << '\n';  // 在这里使用
  
  return 0;
}
```

在上面的例子中，每个变量都是在第一次使用的上一行定义的。没有必要严格遵守这一点 -- 如果你喜欢，交换第五行和第六行，那也没什么关系。

> ### 最佳实践
>
> 定义你的局部变量，尽可能接近它们的第一次使用，因为比较合理。

# 测验

问题1:

下面的程序打印的是什么

```c++
#include <iostream>

void doIt(int x)
{
  int y{ 4 };
  std::cout << "doIt: x = " << x << " y = " << y << '\n';
  
  x = 3;
  std::cout << "doIt: x = " << x << " y = " << y << '\n';
}

int main()
{
  int x{1};
  int y{2};
  
  std::cout << "main: x = " << x << " y = " << y << '\n';
  doIt(x);
  std::cout << "main: x = " << x << " y = " << y << '\n';
  return 0;
}
```

```text
main: x = 1 y = 2
doIt: x = 1 y = 4
doIt: x = 3 y = 4
main: x = 1 y = 2
```




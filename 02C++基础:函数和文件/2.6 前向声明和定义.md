# 前向声明和定义

看看这个看似单纯的示例程序

```c++
#include <iostream>

int main()
{
  std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
  return 0;
}

int add(int x,int y)
{
  return x + y;
}
```

你会期望这个程序能产生以下结果:

```text
The sum of 3 and 4 is: 7
```

但是事实上，它根本无法编译！在Visual Studio产生以下编译错误:

```text
add.cpp(5) :error C3861: 'add': identifier not found
```

这个程序不能被编译的原因是编译器按顺序编译代码文件的内容。当编译器到main的第五行调用add函数时，它不知道add是什么，因为我们直到第九行才定义了add! 这就产生了错误，标识符未找到。

旧版本的Visual Studio会产生一个额外的错误:

```text
add.cpp(9) : error C2365: 'add' : redefinition; previous definition was 'formerly unknown identifier'
```

这有点误导人，因为一开始就没有定义add, 尽管如此，我们还是应该注意到，一个错误产生许多冗余或者相关的错误或警告是相当常见的。

> ### 最佳实践
>
> 在处理程序中的编译错误的时候，一定要先解决产生的第一个错误，然后再编译。

为了解决这个问题，我们需要解决编译器不知道什么是add的问题。有两种常见的方法来解决这个问题。

# 选项1: 重新排列函数定义

解决这个问题的一个方法是重新安排函数定义的顺序，使add被定义在main之前。

```c++
#include <iostream>

int add(int x,int y)
{
  return x + y;
}

int main()
{
  std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
  return 0;
}
```

这样，当main调用add的时候，编译器就已经知道add是什么了。因为这是一个如此简单的程序，所以这种改变相对容易做到。然而，在一个比较大的程序中，要搞清楚哪些函数调用了哪些其他函数(以及顺序)，从而可以按顺序声明它们，这很可能会很难。

此外，这个方案也不是总能够实现，比如，我们要写一个有两个函数A和B的程序，如果函数A调用函数B, 而函数B又调用函数A, 那么就没有一种让编译器满意的方式来安排函数的顺序。如果你先定义A，编译器会抱怨它不知道B是什么。如果你先定义B，编译器会抱怨它不知道A是什么。

# 选项2: 使用预声明

我们也可以通过使用前向声明来解决这个问题。

`前向`声明允许我们再实际定义标识符之前告诉编译器标识符的存在。

在函数的情况下，我们可以在定义函数体之前，告诉编译器函数的存在。这样，当编译器遇到该函数调用的时候，就会明白我们正在进行函数调用，并且可以检查以确保我们对函数的调用是正确的，即使它还不知道函数的定义方式和位置。

为了些一个函数的前向声明，我们使用一个称为`函数原型`的声明语句。函数原型由函数的返回类型、名称、参数组成，但是没有函数主体（大括号和它们之间的所有内容），以分号结束。

这是一个add函数的函数原型

```c++
int add(int x, int y);   // 函数原型包括返回类型、名字、参数和分号，没有函数体！！！
```

现在，这是我们没有编译的原始程序，用一个函数原型作为add函数的前向声明

```c++
#include <iostream>

int add(int x,int y);   // 前向声明add()  使用函数原型

int main()
{
  std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';  // 能正常工作，因为我们在前面对add执行了前向声明
  return 0;
}

int add(int x,int y)  //  即使add()的主体直到这里才定义
{
  return x + y;
}
```

现在，当编译器在main中调用add的时候，它将知道add是什么样子的(一个接收两个整数参数，并返回一个整数的函数)，它不会报错。

值得注意的是，函数原型不需要指定参数的名称。在上面的代码中，你也可以像这样前向声明你的函数

```c++
int add(int, int) // 有效的函数原型
```

然而，我们更喜欢给我们的参数命名(使用和实际函数相同的名称)，因为这可以让你通过查看函数原型就能了解函数参数是什么，否则，你将不得不找到函数的定义。

> ### 最佳实践
>
> 在定义函数原型的时候，包含参数名。你可以通过在函数声明上使用复制/粘贴来轻松创建前向声明。不要忘记最后的分号。

# 忘记了函数体

新手程序员经常想知道，如果它们向前声明一个函数，但是没有定义它，会发生什么。

答案： 视情况而定。如果做了前向声明，但从未调用函数，则程序将正常编译和运行。然而，如果做了前向声明并调用了函数，但是程序从未定义该函数，则程序可以正常编译，但是链接器会抱怨它无法解析函数调用。

考虑以下程序:

```c++
#include <iostream>

int add(int x, int y);   // 使用函数原型前向声明函数add

int main()
{
  std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
  return 0;
}

// 没有定义函数add的函数体
```

在这个程序中，我们向前声明函数add，我们也调用add，但是我们从来没有在任何地方定义add。当我们尝试编译这个程序的时候，Visual Studio产生了以下信息。

```text
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

# 其他类型的前向声明

前向声明最常被用于函数。然而，前向声明也可以用于C++中的其他标识符，如变量和用户定义类型。变量和用户定义类型的前向声明有不同的语法，我们将在以后的课程中介绍这些内容。

# 声明 vs 定义

在C++中，你经常会听到"声明"和"定义"这两个词，它们经常相互使用。它们是什么意思呢？你现在已经有了足够的框架来理解这两者之间的区别。

定义实际上是实现(对于函数或者类型)或者实例化(对于变量)标识符。下面是一些定义的例子:

```c++
int add(int x, int y)   // 实现函数add
{
  int z{ x + y };   //  实例化变量z
  return z;
}
```

需要一个定义来满足链接器。如果你在没有提供定义的情况下使用一个标识符，链接器会给出错误:

单定义规则(one definition rule， 简称ODR) 是C++中一个著名的规则。ODR有三个部分：

1. 在一个给定的文件中，一个函数、对象、类型或者模版只能有一个定义
2. 在一个给定的程序中，一个对象或者普通函数只能有一个定义。之所以有这样的区分，是因为程序可以有多个文件(我们将在下一课中介绍)
3. 类型、模版、内联函数和变量可以在不同的文件中有用相同的定义。我们还没有涉及到这些东西中的大部分，所以现在不用担心这个问题 -- 我们会在相关的时候再提出来。

违反ODR的第一部分将导致编译器发出一个重新定义的错误。违反第二条将可能导致链接器发出重新定义错误。违反第三条将导致未定义行为。

下面是一个违反第一条的例子：

```c++
int add(int x, int y)
{
  return x + y;
}

int add(int x, int y)  // 违反了ODR原则，我们定义了两次
{
  return x + y;
}

int main()
{
  int x;
  int x;  // 违反ODR原则，我们又一次定义了x
}
```

由于上述程序违反了ODR第一条，导致Visual Studio编译器发出了以下编译错误

```text
project3.cpp(9): error C2084: function 'int add(int,int)' already has a body
project3.cpp(3): note: see previous definition of 'add'
project3.cpp(16): error C2086: 'int x': redefinition
project3.cpp(15): note: see declaration of 'x'
```

> ### 给高级读者
>
> 公用一个标识符但是具有不同参数的函数被认为是不同的函数。我们将在第 10.7 -- 函数重载  中进一步探讨这个问题。

`声明`是告诉编译器一个标识符的存在及其类型信息的语句。下面是一些声明的例子。

```c++
int add(int x, int y);   // 告诉编译器一个名为add的函数，它接受两个int形参并返回一个int值
int x;  // 告诉编译器一个名为x的整形变量
```

声明就是满足编译器所需要的全部内容。这就是为什么我们可以使用前向声明来告诉编译器关于一个标识符的信息，而这个标识符实际上要到后面才会被定义。

在C++中，所有的定义也都可以作为声明。这就是为什么int x在我们的例子中既是定义又是声明的原因。既然`int x`是一个定义，它也是一个声明。在大多数情况下，定义可以满足我们的目的，因为它同时满足了编译器和链接器的要求。我们只需要在一个标识符被定义之前就使用它，就需要提供一个显式声明。

虽然所有的定义都是声明，但反过来就不对了：所有的声明都不是定义。这方面的一个例子是函数原型 -- 它满足编译器的要求，但是不满足链接器的要求。这些不是定义的声明称为`纯声明`。其他类型的纯声明包括变量的前向声明和类型声明(你会在以后的课程中遇到这些，现在不需要担心)。

ODR不适用于纯声明(这是一个定义规则，而不是一个声明规则)，所以你可以为一个标识符搞任意多个纯声明(虽然多于一个是多余的)

> ### 作者笔记
>
> 通常来说，"声明"一词通常用来表示"一个纯粹的声明"，"定义"用来表示"一个同时作为声明的定义"。因此，我们通常会把 `int x;`称为定义，尽管它既是一个定义又是一个声明。

# 测验

问题1:

什么是函数原型？

函数原型是一个声明语句，包括函数的名称、返回类型和参数。它不包括函数体

问题2:

声明是前向声明？

前向声明告诉编译器，一个标识符在实际定义之前就已经存在了。

问题3:

我们如何声明前向声明？

对于函数来说，函数原型可以作为正向声明。

其他类型的标识符(如变量和用户自定义类型)有不同的正向声明语法。

问题4:

写出该函数的前向声明(带上参数名)

```c++
int doMath(int first, int second, int third, int fourth)
{
  return first + second * third / fourth;
}
```

```c++
int doMath(int first, int second, int third, int fourth);
```

问题5:

对于以下每个程序，请说明它们是编译失败、链接失败、两者都失败，还是编译成功和链接成功。如果你不确定，请尝试编译它们！

```c++
#include <iostream>

int add(int x, int y);

int main()
{
  std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << '\n';
  return 0;
}

int add(int x, int y)
{
  return x + y;
}
```

无法编译。编译器会抱怨在main中调用的add和前向声明的参数数量不一样。

```c++
#include <iostream>

int add(int x, int y);

int main()
{
  std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << '\n';
  return 0;
}

int add(int x, int y, int z)
{
  return x + y + z;
}
```

无法编译。编译器会抱怨找不到一个匹配接受3个参数的add函数，因为正向声明的add函数只接受两个参数。

```c++
#include <iostream>

int add(int x, int y);

int main()
{
  std::cout << "3 + 4 + 5 = " << add(3, 4) << '\n';
  return 0;
}

int add(int x,int y,int z)
{
  return x + y + z;
}
```

无法链接。编译器会将add的正向声明原型和main中的add函数调用相匹配。然后没有实现过接受两个参数的add()函数(我们只实现了一个接受3个参数的函数)，所以链接器会抱怨。

```c++
#include <iostream>

int add(int x, int y, int z);

int main()
{
  std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << '\n';
  return 0;
}

int add(int x, int y, int z)
{
  return x + y + z;
}
```

编译和链接。函数调用add() 和前向声明的原型匹配，实现的函数也匹配。
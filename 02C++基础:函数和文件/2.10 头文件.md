# 头文件



# 头文件以及它的目的

随着程序越来越大(并使用更多的文件)，必须正向声明每一个在不同文件中定义的你想使用的函数，这变得越来越坑爹。如果你能把所有的正向声明放在一个地方，然后在你需要的时候导入它们，那不是很好吗？

C++代码文件(扩展名为.cpp) 并不是C++程序中常见的唯一后缀，另一种类型的文件叫做`头文件`。头文件的扩展名通常是`.h`。但是你偶尔也会看到它们的扩展名是`.hpp` 或者根本没有扩展名。头文件的主要目的是向代码文件传播声明。

> ### 主要见解
>
> 头文件允许我们将声明放在一个位置，然后在我们需要的地方导入它们。这可以节省在多文件程序中的大量打字时间。

# 使用标准库头文件

考虑以下程序:

```c++
#include <iostream>

int main()
{
  std::cout << "Hello, World!";
  return 0;
}
```

这个程序使用`std::cout`向控制台打印"Hello, World!"。然而，这个程序从来没有提供过std::cout的定义或者声明，那么编译器怎么知道std::cout是什么？

答案是std::cout已经在"iostream"头文件中进行了前向声明。当我们执行`#include <iostream>`的时候，我们要求预处理器将所有内容(包括std::cout的前向声明)从"iostream"文件中复制到本文件中。

> ### 主要见解
>
> 当你`#include` 一个文件的时候，被包含文件的内容会被插入到包含点。这提供了一种从另一个文件中提取声明的有用方法。

考虑以下如果iostream头不存在会发生什么，无论你在哪里使用std::cout，你都必须手动输入或者复制所有std::cout相关的声明到每个使用std::cout文件的顶部！这将需要很多关于如何实现std::cout的只是，并且会有大量的工作。更糟糕的是，如果一个函数原型发生了变化，我们将不得不手动更新所有的前向声明。对比之下，只使用`#include iostream` 要简单很多。

说到函数和变量，值得注意的是，头文件一般只包含函数和变量的声明，而不包含函数和变量的定义(否则会导致违反一定义规则)。std::cout是在iostream头文件中正向声明的，但定义为C++标准库的一部分，在链接器阶段会自动链接到你的程序中。

![img](https://blogimg.ficapy.com/learncpp/IncludeLibrary.png)

> ### 最佳实践
>
> 头文件一般不应该包含函数的和变量的定义，这样才不会违反ODR规则，符号常量是一个例外(我们在第 4.13节 -- const,constexpr和符号常量 再说)

# 编写你自己的头文件

现在让我们回到上节课讨论的例子，当我们离开的时候，我们有两个文件, add.cpp和main.cpp，看起来像这样

add.cpp

```c++
int add(int x, int y)
{
  return x + y;
}
```

main.cpp

```c++
#include <iostream>

int add(int x, int y);  // 使用函数原型进行前向声明

int main()
{
  std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
  return 0;
}
```

（如果你从头开始重新创建这个例子，不要忘记了在你的项目中加入add.cpp， 这样它就会被编译进去）。

在这个例子中，我们使用了一个前向声明，这样编译器在编译main.cpp的时候就会知道标识符add是什么。如前所述，为每一个你想使用的在另外一个文件中的函数手动添加前向声明会变得很没有意思。

让我们写一个头文件来减轻我们的负担。编写头文件非常简单，因为头文件只由两部分组成

1. 头文件卫士， 我们将在写一节课中详细讨论
2. 头文件的实际内容，应该是我们希望其他文件能够看到的所有标识符的前向声明

在项目中添加头文件和添加源文件的工作原理类似(看2.7节 -- 由多个代码文件的程序)。如果使用集成开发环境，请执行同样的步骤，并在被问到时选择Header而不是Source。如果使用命令行，只需要在你喜欢的编辑器中创建一个新文件

> ### 最佳实践
>
> 在命名头文件的时候使用 .h 后缀

头文件通常和代码文件配对，头文件为相应的代码文件提供前向声明。由于我们的头文件将包含add.cpp中定义的函数的前向声明，我们将把我们的新头文件称为add.h

> ### 最佳实践
>
> 如果一个头文件和一个代码文件配对(比如add.h和add.cpp)，它们应该都有相同的基本名称(add)

这里是我们完成的头文件

add.h

```c++
// 1. 这里我们确实应该有一个头卫士，但为了简单起见，我们省略它(我们将在下一节课中讨论头卫士)
// 2. 这是.h文件的内容， 也是声明的位置
int add(int x, int y); // add的函数原型， 不要忘记添加分号
```

为了在main.cpp中使用这个头文件，我们使用`#include`(使用引号，而不是角括号)

main.cpp

```c++
#include <iostream>
#include "add.h"   // 在这个地方插入add.h的内容， 注意不要使用 <>

int main()
{
  std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
  return 0;
}

```

add.cpp

```c++
int add(int x,int y)
{
  return x + y;
}
```

当预处理器处理`#include add.h`的时候，它会在此时将add.h的内容复制到当前文件中。因为我们的add.h包含了函数add的前向声明，所以该前向声明被复制到main.cpp中。最终的结果是一个与我们在main.cpp顶部手动添加正向声明的程序在功能上是一样的。

因此，我们的程序将正确的编译和链接

![img](https://blogimg.ficapy.com/learncpp/IncludeHeader.png)

# 在相应的源文件中包含头文件

你会发现，大多数Source文件都包含了相应的头文件，即使它们不需要。为什么会这样呢？

在Source文件中加入头文件可以增加前向兼容性。很有可能在未来，你会添加更多的函数或者修改现有的函数，它们需要知道彼此的存在。

一旦我们深入了解标准库，你将包含许多标准库头文件。如果在头文件中你需要include，那么你可能需要在函数声明中使用它。这意味着你要在Source文件中也要做相同的include。最终会导致Source文件中包含重复的include。通过在源文件中包含头文件，源文件可以访问头文件中可以访问的所有内容。

在开发库的过程中，在源文件中加入你的头文件甚至可以帮助你及早发现错误。关于这个讨论，请看这个[评论](https://www.learncpp.com/cpp-tutorial/header-files/comment-page-8/#comment-398571)

> ### 最佳实践
>
> 当编写源文件的时候，请包含相应的头文件(如果有的话)，即使你目前还不需要它

# 疑难解答

如果你收到一个编译器错误，表明没有找到add.h，请确定文件的名字确实是add.h。根据你创建和命名的方式，这个文件有可能被命名为add(没有扩展名)或者add.h.txt或者add.hpp，同时确保它和你的其他代码在同一个目录下面。

如果你得到一个关于函数add没有被定义的链接器错误，请确保你已经在项目中添加了add.cpp，这样函数add的定义就可以被链接到程序中。

# 角括号和双引号

你可能会好奇为什么我们对iostream使用角括号，而对add.h使用双引号。相同文件名的头文件可能存在与多个目录中。我们使用角括号和双引号有助于给编译器一个线索，让它知道应该在哪里寻找头文件。

当我们使用角括号的时候，我们是在告诉预处理器，这不是我们自己写的头文件。编译器将只在include目录指定的目录中搜索头文件。include目录是作为 项目/IDE设置/编译器设置 的一部分。通常默认为包含 编译器/操作系统附带的头文件目录。编译器不会在你的项目的源代码目录搜索头文件。

当我们使用双引号的时候，我们实在告诉预处理器，这是一个我们编写的头文件。编译器将首先搜索当前目录中的头文件。如果在那里找不到匹配的头文件，他将搜索include目录。

> ### 规则
>
> 使用双引号来包含你已经写好的头文件，或者预计在当前目录中可以找到的头文件。使用角括号来包含编译器/操作系统/或者你在系统其他地方安装的第三方库所附带的头文件

# 为什么iostream没有.h扩展名

另外一个常见的问题是"为什么iostream(或者其他标准库头文件)没有.h扩展名？"，答案是, iostream.h是一个与iostream不同的头文件！要解释这个问题需要上一堂简短的历史课。

当C++刚刚诞生的时候，标准库中的所有头文件都是以.h为后缀。生活是是如此统一，这很好。当ANSI委员会对语言进行标准化的时候，它们决定将标准库中的所有功能都移动到std命名空间中，以帮助避免和用户定义的标识符的命名冲突。然而，这带来了一个问题：如果他们把所有的功能都移动到std命名空间，那么所有的旧程序(包括iostream.h)都不能再工作了。

为了解决这个问题，我们引入了一组新的头文件，它们使用相同的名称，但是没有.h后缀。这些新的头文件的所有功能都在std命名空间内，这样一来，包含`#include <iostream.h>`的旧程序就不需要重写，而新的程序使用`#include <iostream>`.

此外，许多从C语言继承的、在C++中仍然有用的库都被赋予了C前缀(比如，stdlib.h变成了cstdlib)。这些库的功能也被移动到了std命名空间，以帮助避免命名空间上的冲突。

> ### 最佳实践
>
> 当从标准库中包含一个头文件的时候，如果存在无扩展名的版本(不含有.h)，请使用它。用户定义的头文件仍然使用.h扩展名

# 包含从其他目录的头文件

另外一个常见的问题涉及到如何包含其他目录的头文件。

一种(不好的) 方法是在include行中包含一个你想包含的头文件的相对路径，比如

```c++
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

虽然这样做可以编译(假设文件存在于这些相对目录中)，但是这种方法的缺点是，它要求你在代码中反映你的目录结构。如果你更新了你的目录结构，你的代码将无法工作。

一个更好的方法是告诉编译器或者你的IDE，你有一堆头文件在其他地址，这样当它在当前目录下找不到它们的时候，就会在那里查找。这一般可以通过在IDE项目设置中设置一个包含路径或者搜索目录来实现

> ### 对于Visual Studio用户来说
>
> 在 "解决方案资源管理器" 中右击项目，选择 "属性"，然后选择 "VC++目录"，从这里，你会看到一行名为Include Directoreies的内容，添加你想让编译器在那里搜索附加头文件的目录

> ### 对于Code::Blocks用户
>
> 在Code::Blocks中，加入Porject菜单，选择 Build Options，然后选择 Search directories选项。添加你希望编译器在那里额外搜索头文件的目录

> ### 对于GCC/G++用户
>
> 使用g++，你可以使用 -I 选项来指定一个备用的include目录
>
> ```bash
> g++ -o main -I/source/includes main.cpp
> ```

这种方案的好处是，如果你改变了你的目录结构，你只需要改变一个编译器或者IDE的设置，而不是每个代码文件。

# 头可能会包含其他头

常见的情况是，一个头文件需要一个声明或者定义，而这个声明或者定义却存在与另一个头文件中，正因为如此，头文件中经常会`#include`其他头文件。

当你的代码文件`#include`第一个头文件的时候，你也会得到第一个头文件所包含的所有头文件(递归，依次类推)。这些额外的头文件有时候被称为传递依赖transitive include。因为它们是隐式而非显式的包含。

这些依赖的内容可以在你的代码文件中使用。然而，你不应该依赖这种方式包含的头文件的内容。头文件的实现可能会随着时间的推移而改变，或者在不同的系统中是不同的。如果发生这种情况，你的代码可能只能在某些系统上编译，或者现在能编译。但将来无法编译，通过明确的`#include`导入你需要的头文件，可以很容易避免这种情况

> ### 最佳实践
>
> 每个文件都应该明确的`#include` 它所需要编译的头文件，不要依赖从其他头文件顺便包含的头文件。

遗憾的是，当你的代码文件意外的依赖于另外一个头文件的内容时，没有简单的方法来检测。

> 问：我没有加入<someheader.h>，但是我的程序还能用，为什么？
>
> 这是本网站上最常见的问题之一。答案是，它很可能能工作，因为你包含了一些其他的头文件(比如<iostream>), 而这些头文件本身包含了<someheader.h>。虽然你的程序能编译，但是根据上面的最佳实践，你不应该依赖这个。你能正常编译的程序可能在你朋友的机器上无法正常编译。

# include头文件的顺序

如果你的头文件写的很好，并且`#include`包含了所有需要的东西，那么include的顺序就不应该有问题。然而，按照一定的顺序包含你的头文件可以帮助你发现错误，因为你的头文件可能没有包含它们需要的一切。

> ### 最佳实践
>
> 你的 `#include` 顺序如下： 显示你自己写的头文件，然后是第三方库头文件，然后是标准库头文件，每个部分的头文件按照字母顺序排列。

这样一来，如果你写的头文件缺少了第三方库或者标准库的include，就更有可能导致编译错误，所以你可以修复它。

# 头文件最佳实践

这里还有一些关于创建和使用头文件的建议

- 一定要包含头卫士(下节课会讲)
- 不要在头文件中定义变量和函数(全局常量是个例外 -- 稍后会介绍)
- 赋予你的头文件与它们所关联的源文件相同的名称(比如grades.h和grades.cpp配对)。
- 每个头文件应该都有一个特定的任务，并且尽可能的独立。比如，你可以把所有与功能A有关的声明放在A.h中，而把所有与功能B有关的声明放在B.h中。这样，如果你以后只关心A, 就可以只包含A.h，而不会得到任何与B有关的东西。
- 注意你需要为你在代码文件中使用的功能明确包含哪些头文件
- 你写的每一个头都应该自己编译(它应该#include 它需要的所有的依赖)
- 只 #include 你需要的东西(不要因为你能包含所有的东西)
- 不要#include .cpp文件




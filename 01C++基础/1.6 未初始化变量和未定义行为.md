# 未初始化变量和未定义行为

# 未初始化变量

和一些编程语言不通，C/C++不会自动的将大多数变量初始化为一个给定的值(比如0)。因此，当一个变量被编译器分配到一个内存位置时，该变量的默认值是该内存位置中恰好已经存在的任何(垃圾)值！一个没有被赋予已知值(通常是通过初始化或赋值)的变量被称为未初始化变量。

> ### 作者笔记
>
> 许多读者期望`初始化`和`未初始化`这两个术语严格对立，但是它们并不是这样的！`初始化`是指对象在定义的时候被提供了初始值。未初始化意味着对象没有被赋予给一个已知的值（通过任何方式，包括赋值）。因此，一个没有被初始化但是随后被赋值的对象不再是未初始化对象(因为它已经被赋予了一个已知值)
>
> 概括来说:
>
> - 初始化 = 对象在定义时被赋予一个已知的值
> - 赋值 = 对象在定义后被赋予一个已知的值
> - 未初始化 = 对象尚未被赋予一个已知的值

> 旁注
>
> 这种缺乏初始化的情况时从C语言中继承下来的性能优化。那时候计算机还特别慢。想象一下，如果你要从一个文件中读取100,000个值，你可能会创建100,000个变量，然后用文件中的数据填充它们。
>
> 如果C++在创建的时候用默认值初始化所有这些变量，这将导致10万次初始化(这是很慢的)。而且没什么好处(因为反正最后你都要覆盖掉这些值)。
>
> 现在，你应该总是初始化你的变量，因为这样做的成本与收益相比是微不足道的。一旦你对这门语言比较熟悉，可能在某些情况下，你会为了优化某地而省略初始化。但这应该是故意而为的。

使用未初始化的变量的值会导致意想不到的后果。可以考虑以下程序：

```c++
#include <iostream>

int main()
{
  // 定义一个整数类型的变量x
  int x;   //  这个值并没有被初始化
  // 打印x的值
  std::cout << x;  // 鬼知道输出什么，因为x没有被初始化
  return 0;
}
```

在这种情况下吗，计算机将一些未使用的内存分配给x，然后将驻留在该内存位置的值发送给`std::cout`，它将打印该值(解释为一个整数)。但是会打印出什么值呢？答案是：谁知道呢！，而且每次运行程序的时候，答案可能会改变。笔者在Visual Studio中运行这个程序的时候，std::cout一次打印的值是7177728，下一次打印的值是5277592。欢迎自行编译并运行该程序（你的电脑不会爆炸）。

> ### 旁注
>
> 一些编译器，比如Visual Studio，在使用debug编译配置的时候，会将内存的内容初始化为某个预设值。在使用release构建的时候，这种情况不会发生，因此，如果你想自己运行上面的程序，请确保你使用的是release构建配置(参照第0.9节)。例如，如果你在Visual Studio debug配置中运行上述程序，它将始终如一地打印-858993460，因为这是Visual Studio在debug配置中初始化内存的值（解释为整数）。

大多数现代编译器会尝试检测是否有一个变量在没有给定值的情况下被使用。如果它们能够检测到这一点，它们通常会发出一个编译时错误。例如，在Visual Studio上编译上面的程序会产生以下警告。

```text
c:\VCprojects\test\test.cpp(11) : warning C4700: uninitialized local variable 'x' used
```

如果你的编译器因为这个原因不让你编译和运行上述程序，这里有一个可能的解决方案来解决这个问题

```c++
#include <iostream>

void doNothing(int&) // 现在不要担心&是什么，我们只是用它来欺骗编译器，让它认为使用了变量x
{
}

int main()
{
  // 定义一个整数变量x
  int x;  // 这个变量没有被初始化
  
  doNothing(x);  // 让编译器认为我们正在给这个变量赋值
  
  // 将x的值输出
  std::cout << x;
  
  return 0;
}
```

使用未初始化的变量是新手程序员最常犯的错误之一，不幸的是，它也可能是最具挑战性的调试之一（因为如果未初始化的值恰好被分配到内存中的一个有合理值的位置，比如0，那么程序会继续正常执行）。

这就是`总是初始化你的变量`最佳实践的主要原因。

# 未定义的行为

使用未初始化变量的值是我们第一个未定义行为的例子。未定义(通常缩写为UB)是执行代码的结果，其行为没有被C++语言很好地定义。对于这种情况，C++语言没有任何规则来决定如果使用未给出已赋值的变量会发生什么。因此，如果你真的这么做，就会产生未定义的行为。

实现未定义行为的代码可能会出现以下任何毛病

- 你的程序每次运行都会产生不同的结果
- 你的程序总是产生同样的错误结果
- 你的程序行为不一致(有时候正确，有时候不正确)
- 你的程序似乎在工作，但是程序后续产生了错误的结果
- 你的程序崩溃了，要么立即崩溃，要么以后崩溃
- 你的程序在某些编译器上可以工作，但是在其他编译器上不行
- 你的程序可以正常工作，直到你改变了其他一些看似不相关的代码

或者，你的代码实际上可能还是会产生正确的行为。未定义的行为的本质是，你永远不知道你会得到什么，你是否每次都乎得到它，以及当你做其他改变时，该行为是否会改变。

如果你不小心，C++会包含很多情况，这些情况可能导致未定义的行为。在以后的课程中，只要遇到这些情况，我们就会指出来。请注意这些情况在哪里，并确保避免它们。

> ### 规则
>
> 注意避免所有未定义行为的情况，例如使用未初始化的变量。

> ### 作者笔记
>
> 我们从读者那里得到的最常见的一种评论是："你说我不能做X, 但我还是做了，而且我的程序还能用！！！为什么?"
>
> 有两种常见的答案。最常见的答案是，你的程序实际上表现出了未定义的行为，但是未定义的行为恰好产生了你想要的结果.......目前是这样。明天(或许是在另外一个编译器或机器上)可能就不会了。
>
> 另外，有时编译器的作者在语言需求比较严格的时候，会随意处理这些需求。例如，标准可能会说，"你必须先做X再做Y"，但是编译器作者可能会觉得这是不必要的，即使你不先做X，Y也能工作。这不会影响正确编写的程序的运行，但是可能会导致错误编写的程序仍然可以工作。因此，对上述问题的另外一种问答是，你的编译器可能只是没有遵守标准！！！这是常有的事情。你可以通过关闭编译器扩展来避免大部分此类情况。如第0.10节 -- 配置编译器:编译器扩展  中说的那样。

# 测验

问题1:

什么是未初始化变量，为什么要避免使用它们？

未初始化的变量是程序没有给它赋值(通常通过初始化或者赋值)。使用存储在未初始化变量中的值将导致未定义的行为。

问题2:

什么是未定义行为，如果你做了一些表现出未定义行为的事情，会发生什么？

未定义的行为是语言没有很好的定义其行为的代码的执行结果，结果几乎可以是任何东西，包括行为正确的东西。


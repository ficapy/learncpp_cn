# 变量赋值和初始化

在上一节课中，我们介绍了如何定义一个我们可以用来存储值的变量。在这一节课中，我们将探讨如何将值实际放入变量中并使用这些值。

提醒一下，这里有一个简短的片段，首先分配一个名为x的整数变量，然后再分配两个名为y和z的整数变量。

```c++
int x;   // 定义一个名为x的int类型变量
int y,z; // 定义两个整数类型变量，名字分别为y和z
```

# 变量赋值

在定义了一个变量之后，你可以使用`=`操作符给它一个值(在一个单独的语句中)。这个过程被称为`赋值赋值`（简称`赋值`）。

```c++
int width; // 定义了一个名字为width的int类型变量
width = 5; // 将值5复制赋值到变量width

// 现在变量width的值是5了
```

复制赋值之所以这样命名，是因为它将`=`运算符右侧的值复制到了运算符左侧的变量中。`=`运算符被称为`赋值运算符`。

这里有一个例子，我们使用了两次赋值

```c++
#include <iostream>

int main()
{
  int width;
  width = 5; // 将值5复制赋值到变量width
  // 现在变量width的值是5了
  width = 7;
  // 现在变量width的值是7了
  return 0;
}
```

当我们将值7赋给变量width时，之前的值5将会被覆盖。普通变量一次只能保持一个值。

> ### 警告
>
> 新手程序员最常犯的错误之一是混淆了赋值操作符(=)和等价操作符(==)。赋值(=)是用来给变量赋值的，而等价(==)是用来测试两个操作数的值是否相等。

# 复制初始化和直接初始化

赋值的一个缺点是，它至少需要两个语句：一个是定义变量，一个是赋值。

这两个步骤可以结合起来，当定义一个变量的时候，也可以同时为变量提供一个初始值。这就是所谓的`初始化`。

C++支持三种基本的方式来初始化一个变量。首先，我们可以通过使用等号进行`复制初始化`。

```c++
int width = 5; // 将值5复制初始化赋值到变量width
```

就像复制赋值一样，这将等式右边的值复制到左边被创建的变量上。

其次，我们可以通过使用小括号进行`直接初始化`。

```c++
int width(5);  // 将值5直接初始化到变量width
```

对于简单的数据类型(比如整数)，复制初始化和直接初始化基本上是一样的。我们会在后面的教程中看到复制初始化和直接初始化的区别。

# 列表初始化

不幸的是，基于圆括号的直接初始化不能应用于所有类型的初始化(比如初始化一个带有数据列表的对象)。为了提供更一致的初始化机制，使用花括号的列表初始化(有时候也称为统一初始化，或者大括号初始化)。

列表初始化有两种形式

```c++
int width{5};  //  将值5直接列表初始化到变量width(首选)
int height = {6}; // 将值6列表初始化复制到变量height
```

这两种形式的功能几乎完全相同，但是一般倾向于直接形式。

用空括号初始化一个变量表示值初始化。`值初始化`通常将变量初始化为零(或者空，如果它更适合给定类型)

```c++
int width{};  // 值初始化为0
```

列表初始化还有一个好处，就是不允许`向下`转换，这意味着，如果你试图使用列表初始化来初始化一个变量，而这个变量的值又不能安全的保持，编译器就会抛出一个警告或者错误。比如

```c++
int width{4.5}; // 错误, 并不是所有的双精度值都能转换成int
```

在上面的代码片段中，我们试图将一个有小数部分(0.5)的数字(4.5)分配给一个整数变量(它只容纳没有小数部分的数字)。复制和直接赋值会放弃小数部分，导致将值4初始化为变量width。然而，对于列表初始化，这将导致编译器发生错误(一般来说，这是一件好事，因为很少需要丢失数据)。允许进行不丢失潜在数据的转换。

> ### 最佳实践
>
> 尽可能的使用直接列表初始化

> 问: C++提供了复制初始化，直接初始化和列表初始化，以及复制赋值。有没有直接赋值或者列表赋值？
>
> 没有，C++不支持直接赋值或者列表赋值语法。

> 问：什么时候用{0}初始化，什么时候用{}
>
> 如果你真的要使用该值，请使用显式初始化
>
> ```c++
> int x{0};  // 显式初始化到0
> std::cout << x; // 在这里我们要使用值0
> ```
>
> 如果是临时值，以后将会被替换，则使用值初始化{}
>
> ```c++
> int x{};  // 值初始化
> std::cin >> x; // 这里我们将替换掉值
> ```

# 初始化你的变量

在创建时初始化你的变量。你可能最终会发现，在某些情况下，你会因为某个特定的原因而忽略这个建议(例如，在代码的性能关键部分使用了大量的变量)，这并没有问题，只要是故意的。

关于这个话题的更多讨论，Bjarne Stroustrup(C++的创造者)和Herb Sutter(C++专家)在[这里](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object)做了推荐

在1.6节 -- 未初始化的变量和未定义的行为中，我们将探讨如果你试图使用一个没有明确定义的变量会发生什么。

> ### 最佳实践
>
> 在创建的时候初始化你的变量

# 初始化多个变量

在上一节中，我们注意到，通过使用逗号分隔名称，可以在一条语句中定义多个相同类型的变量。

```c++
int a, b;
```

我们也注意到，最佳实践是完全避免这种语法。然而，由于你可能会遇到其他使用这种风格的代码，因此，即使只是为了强调你应该避免它的一些原因，稍微多讨论一下也是有用的。

你可以在同一行初始化多个变量

```c++
int a = 5, b = 6;  // 复制初始化
int c(7), d(8);    // 直接初始化
int e{9}, f{10};   // 列表初始化(首选)
```

不幸的是，这里有一个常见的陷阱，当程序员错误的试图使用一个初始化语句来初始两个变量时，就会出现这种情况。

```c++
int a, b = 5;     // 错误(a没有被初始化)
int a = 5, b = 5; // 正确
```

在上面的语句中，变量a没有被初始化，编译器可能会报错，也可能不会。如果没有，这是一种让程序间歇性崩溃的好办法。我们稍后将详细讨论使用未初始化变量会发生生么。

记住这是错误的最好方法是，考虑直接初始化或列表初始化的情况：

```c++
int a, b(5);
int c, d{5};
```

这样以来，似乎就非常清楚了，值5只是用来初始化变量b或d, 并不是a或c。

# 测验时间

问题1:

初始化和赋值的区别是什么

初始化在创建变量的时候给它一个初始值，赋值实在变量创建后的某一个时刻给变量一个值。

问题2:

你应该使用哪种形式的初始化

直接列表初始化

译注: [为什么列表初始化比其他方法更好: Stackoverflow](https://stackoverflow.com/questions/18222926/why-is-list-initialization-using-curly-braces-better-than-the-alternatives)





